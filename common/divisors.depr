# -*- coding: utf-8 -*-
"""
Created on Mon Oct  4 11:24:45 2021

@author: db_wi
"""
##### FUNCTIONALITY WITHIN THIS FILE WAS MOVED TO PRIMEDB!
##### MUCH FASTER WITH PRIME FACTORING!

#TODO:  This would be a *lot* faster if we utilized prime divisors and then
#       expanded them, but I don't have a coherent algo for that :(

# unfortunately, I've implemented this wrong. This does not provide the correct
# answer in cases of large numbers. I've had to revert to the even-slower, 
# naive method. 

# gd_cache = dict()
# def get_divisors(n):
#     global gd_cache
#     if n in gd_cache:
#         return gd_cache[n]
#     d = [1]
#     d2 = [n]
#     j = 2
#     while j*j < n:
#         if not (n%j):
#             if (n//j) in gd_cache:
#                 gd_cache[n] = list(gd_cache[n//j])
#                 for p in gd_cache[n//j]:
#                     p2 = p*(j)
#                     if not p2 in gd_cache[n]:
#                         gd_cache[n].append(p2)
#                 gd_cache[n].sort()
#                 return gd_cache[n]
#             d.append(j)
#             d2.append(n//j)
#         j += 1
#     if j*j == n:
#         d.append(j)
#     d2.reverse()
#     d.extend(d2)
#     gd_cache[n] = d
#     return d

# def get_divisors(n):
#     if n == 0:
#         return None
#     r = [1]
#     j = 2
#     while j*j <= n:
#         if not n%j:
#             r.append(j)
#             if j != n//j:
#                 r.append(n//j)
#         j += 1
#     r.append(n)
#     return r



# same as get_divisors, but remove n


# if __name__ == "__main__":
#     import cProfile
#     import pstats
#     with cProfile.Profile() as pr:
#    
#
#         stats = pstats.Stats(pr)
#         stats.sort_stats(pstats.SortKey.TIME)
#         stats.print_stats()
#         stats.dump_stats(filename="divisors.prof")